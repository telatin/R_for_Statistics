

## using `readxl` to read data from Excel files

R is not used for data entry or storage; you are likely to have data stored as an Excel file, a csv file, in a database, or in some other format generated by a device.

So before we can do any analysis we need to import data.  We do this in code like everything else in R.

Base R (‘base’ R is R as it comes when you first download it) cannot read data from Excel files.  But there are several add-on ‘packages’ that *can* read Excel files (there are packages to read data from most common formats, including Stata, SPSS and GraphPad Prism files!).  Currently the best package for reading Excel files is called `readxl` (there are several others but they do not work as well).

Packages are collections of functions and datasets related to a specific task.  They are most often created by R users for their own use and those that meet certain standards can be shared with the community through the Comprehensive R Archive Network (CRAN) or Bioconductor, which makes it very easy to find and install them.  In addition anyone can produce and distribute a package themselves, eg through GitHub.

Note, while R can read data from text and csv files by itself, the `readr` package makes this easier.  If you want to read data from GraphPad Prims files, there is a package called `pzfx` for this, and the `haven` package allows you to read SPSS, Stata and SAS files.

Here we will import a dataset from Excel using the `readxl` package.  If you already installed `tidyverse` then you already have this package.  Otherwise you can type:

```{r eval=FALSE}
install.packages("readxl") # notice the quotes here
```

The first time you try to install a package, R will ask you where you would like to download packages from.  Select any UK CRAN mirror.

Now the package is installed.  We could now access its functions by using the package name and the function name, but its easier to first type:
  
  ```{r warning=FALSE}
library(readxl) # no quotes this time
```

‘library’ makes all of the functions in a package available for use without having to reference the package each time.  In R terminology everything in the package has been added to the search path, which is the set of places R will look when we refer to an object or a function.

Now we have the function `read_excel()` available, which reads data from an excel file.

Before we dive in and use it, we need to make sure our data is in a sensible place, and we understand how to use the function.  First, save the example data (`treedata.xlsx`) for this tutorial into a ‘data’ subdirectory of your project.

Open the dataset in Excel and make sure you understand the data that is there.

## Read the help!

We are nearly ready to import some data.  But before using a new function its always good to read its documentation.

R and R packages are not as self-explanatory as other software, and so you should expect to spend a fair amount of time, particularly as you are learning R, reading documentation, vignettes, blogs, etc on what R can do, which packages exist, and how to use them.

`read_excel()` has a few different options so first we should look at the help file:
  
  ```{r eval=FALSE}
?read_excel # where does the helpfile appear?
```

Most R help files are structured in the same way.  They have a ‘Description’ section (what does the function do), a ‘Usage’ section (what is the syntax), an ‘Arguments’ section (detail of what all the options mean), a ‘Value’ section (what do I get when I run this) and some Examples.  The examples are usually very helpful.

Notice that `read_excel()` can extract data from different sheets and ranges of an Excel workbook, can use or ignore column names, and allows you to specify the type of data (numeric, dates, text etc) if you want to, or leave it to R to guess.

Many R packages also have vignettes or websites including simpler guides to their use in specific cases.  readxl has a website that you might find helpful:  https://readxl.tidyverse.org/
  
  
  `r example("Loading data into R part 2")`

Now we’ll load the data.  We want to use the ‘walking speed’ data from the walkingspeed.xlsx spreadsheet. Open the spreadsheet in Excel and find this sheet.  The data we want is in the sheet called .....

From the read_excel() help file we can deduce the syntax to load this data into R:
  
```{r }
walkingdat <- read_excel(path="walkingspeed.xlsx", sheet="")
```

(This assumes that the file ‘walkingspeed.xlsx’ is in the current working directory.  The current working directory is shown just above the R console window).  You can see the files in the current working directory in the 'Files' tab on the bottom right of the RStudio window.

This line calls the `read_excel()` function, with the arguments ‘path’, ‘sheet’ set.  The other arguments will be set to their default values, which you can see from the help file.  

We could have set the range of the data in the spreadsheet (I usually do this for safety), but `read_excel()` can figure it out automatically most of the time; by default it picks the biggest continuous chunk of data starting in the top left of the sheet.

Now we have a ‘data frame’ object called TreeData, which includes the data from the Excel sheet ready to process and analyse.  It’s a good idea to check that the data has been extracted as you expected, and we can inspect it in various ways.  Try:
  
`r exercise("Vectors and data frames")`

1. What are the names of the variables that comprise the `walkingdata` dataframe?
2. What is the class of each?
  
A corollary of the fact that all elements of a vector must have the same class is that all the values in a single column of a dataset must have the same class.  That is, you cannot have a column in your dataset that includes the numeric value `3` and the character value `Green`.  This information would need to be stored in a different way.



`r section("Structure of a data frame")`

A data frame is essentially a set of vectors, all of the same length, that have been stuck together into a rectangle such that each row describes unit of one observation, and each column includes a particular attribute of that observation.

This ‘tidy’ format is how we *must* store all our datasets for analysis.  If you have used SPSS, Stata or a relational database you will be familiar with this way of organising data. GraphPad Prism works differently, so you will need to change the way you organise data if you move from GraphPad Prism to R.

See the reference below on ‘tidy data’ for more on how to organise your data into one or more tidy data frames, you may not immediately think this is possible for your dataset, but it is! (and it is essential!)

https://vita.had.co.nz/papers/tidy-data.pdf 

For complex datasets, for example high throughput genomics combined with meta-data, your data might be stored as more than one dataframe, one for the main data and a separate data frame for the meta-data, but it will need to be pooled together .

Once we have our data tidied and loaded into a data frame, we can access each variable as a vector and work on it exactly as we did in the section on vectors above.






```{r eval=FALSE echo=FALSE}
#### THIS IS JUST SOME STUFF LEFT OVER FROM THE PREVIOUS WORKSHEET
# **Answers and comment on the exercises**

### Exercise 1

`log(10)`

`sqrt(2)`

`10^(1/3)`

### Exercise 2


1.  Type `y = x+3` or `y <- x+3`, then `y` to print its value.
2.  Subsequently changing x doesn’t change the value of y.  When y was created it used only the value of x at that time, and changing x afterwards doesn’t change y.
3.  `myname` is a character object.
4.  Use `toupper(myname)`

### Exercise 3

1. `as.numeric(TRUE)` evaluates to 1.  `as.numeric(FALSE)` evaluates to 0.
2. Character strings convert to `NA` (missing) if they are not simple numbers.

### Exercise 4

1. A vector can be a vector of characters
2. Since all the elements of a vector need to be the same type, the numeric `3` gets converted to a character `"3"` when it is combined with a character.  The result is a character vector.
3. Similarly, `TRUE` gets coverted to `1` to make a numeric vector.
4. This returns the mean of the vector.  We didn't have to make the vector object first, we can chain functions together by using one as the argument to another.
5. The `%in%` operator returns true if the left hand side is equal to any of the elements of the vector on the right hand side.
6. This tests whether each element of `vectorB` is equal to `"George"`.
7. `vectorb` is a character, and we can't take its mean.  This throws an error.

### Exercise 5

1. `class()` is not affected by missing values in the vector
2. there is no point for the missing value, but a space where it would have been.
3. a comparison with `NA` returns `NA`.
4. tests each element of a vector to see if it is missing
5. since `is.na()` returns a vector of logicals, this function sums the logicals corresponding to whether each element of the vector is missing or not.  From the exercise above we know that `TRUE` equates to 1 and `FALSE` to 0, so this expression effectively counts the number of missing values in a vector.
:  No clues with this one, but the final answer should be 1.

### Exercise 6

1. `sd(a)`
3. `hist(b)`
4. `a <- rnorm(100,0,1)` (or just `rnorm(100)` will also do)
5. `hist(a[a>0])`

### Exercise 8

1. You can use `names(TreeData)` to get this.
2. Get this from `str(TreeData)` or `lapply(TreeData, class)`

### Exercise 9

1. `aggregate(height ~ health, FUN=median, data=TreeData)`
2. `aggregate(height ~ health + species.name, FUN=median, data=TreeData)`
3. `TreeData2 <- TreeData[ TreeData$location==1 , ]` 
or `TreeData2 <- subset(TreeData, location==1)`

### Exercise 10

1.  You could multiply the table of proportions by 100, either before or after you round it to 2 d.p.  Compare:

`100*round(proptab1, digits=2)`

`round(100*proptab1, digits=2)`

### Exercise 11

1. `t.test( height ~ health , data=TreeData)`
2. You would use `chisq.test`, either passing the variables directly:

   `chisq.test(TreeData$health, TreeData$species)`

   or by using one of the cross-tabs we already generated.

3. A linear regression model can be estimated using `lm` as follows:

```{r eval=FALSE}
lm( height ~ health + species.name , data=TreeData)
```

but to read the output we need to run `summary` on the `lm` object that is created by the `lm` function:

```{r eval=FALSE}
myModel <- lm( height ~ health + species.name , data=TreeData)
class(myModel)
summary(myModel)
```
